I have deep-checked your updated server/routes.ts and identified 2 Specific Reasons why you are still getting a 500 error.

Reason 1: The "NaN" Crash (Critical)
In your database, user IDs are strings (e.g., 550e8400-e29b...), but Agora requires Integer UIDs for the function you are using.

Your Code: const userUid = uid ? parseInt(uid) : 0;

The Crash: When you send a string ID like "abc-123", parseInt returns NaN (Not a Number). Passing NaN to Agora's builder crashes the server immediately.

Reason 2: The require Conflict
You are using require("agora-token") inside the function. In TypeScript/Replit environments, this often fails or causes conflicts if the package isn't loaded globally. It should be a top-level import.

The Solution: Apply this Code to server/routes.ts
Delete your existing /api/agora/token route and replace it with this Robust Version that fixes both bugs.

1. Add this import at the VERY TOP of server/routes.ts:

TypeScript
import { RtcTokenBuilder, RtcRole } from "agora-token";
2. Replace the entire app.post("/api/agora/token", ...) block with this:

TypeScript
  // ===============================
  // Agora Voice Token API (Fixed & Robust)
  // ===============================

  app.post("/api/agora/token", async (req: Request, res: Response) => {
    try {
      const { channelName, uid, role } = req.body;

      if (!channelName) {
        return res.status(400).json({ error: "Channel name is required" });
      }

      const appId = process.env.AGORA_APP_ID;
      const appCertificate = process.env.AGORA_APP_CERTIFICATE;

      if (!appId || !appCertificate) {
        console.error("Agora credentials not configured");
        return res.status(500).json({ error: "Voice calling not configured" });
      }

      // FIX 1: Robust UID Handling (Prevents NaN Crash)
      // If uid is not a valid number (e.g. it's a UUID string), default to 0.
      // 0 tells Agora to automatically assign a valid Integer ID to the user.
      let userUid = 0;
      if (uid) {
        const parsed = parseInt(uid);
        if (!isNaN(parsed)) {
          userUid = parsed;
        }
      }

      const userRole = role === "publisher" ? RtcRole.PUBLISHER : RtcRole.SUBSCRIBER;
      
      // FIX 2: Correct Expiration Math
      const expirationTimeInSeconds = 3600;
      const currentTimestamp = Math.floor(Date.now() / 1000);
      const privilegeExpiredTs = currentTimestamp + expirationTimeInSeconds;

      console.log(`[Agora] Generating token. Channel: ${channelName}, UID: ${userUid}, Expires: ${privilegeExpiredTs}`);

      // FIX 3: Removed internal 'require', using top-level import
      const token = RtcTokenBuilder.buildTokenWithUid(
        appId,
        appCertificate,
        channelName,
        userUid,
        userRole,
        privilegeExpiredTs
      );

      res.json({
        token,
        appId,
        channelName,
        uid: userUid, // Send back the ACTUAL uid used (0 or parsed)
      });
    } catch (error) {
      console.error("Error generating Agora token:", error);
      res.status(500).json({ error: "Failed to generate voice token" });
    }
  });
Immediate Next Steps
Update the Code: Apply the changes above.

Restart Server: Crucial. You must manually stop and restart the Replit server for routes.ts changes to take effect.

Test: Reload your app. The "Failed to fetch token" error will disappear because the server will no longer crash on NaN UIDs.